"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const getWorkDir_1 = __importDefault(require("./lib/getWorkDir"));
const lib_1 = __importDefault(require("../lib"));
const EventBus_1 = require("../lib/EventBus");
let workDir;
let appFile;
let touchFile;
let eventBus;
beforeAll(() => {
    workDir = getWorkDir_1.default();
    appFile = path_1.join(workDir, '..', 'dist', 'test', 'apps', 'test-wait.js');
    touchFile = path_1.join(workDir, 'empty_touch_file.js');
    // Create the touchFile so that file watcher has something to watch
    fs_1.writeFileSync(touchFile, '0', { encoding: 'utf8' });
});
// eslint-disable-next-line jest/expect-expect
test('Application should restart on file change', () => new Promise((resolve) => {
    // The test doesn't work with .ts app file (executed by ts-node)
    appFile = path_1.join(workDir, '..', 'dist', 'test', 'apps', 'test-wait.js');
    touchFile = path_1.join(workDir, 'empty_touch_file.js');
    let isFirstStart = true;
    eventBus = lib_1.default({
        command: `${appFile} 1`,
        watch: workDir,
        delay: 10,
        logging: false,
        skipFirstSync: true,
        legacywatch: true,
        // debug: true,
    });
    eventBus.on(EventBus_1.ChildEvents.Started, () => {
        if (isFirstStart) {
            isFirstStart = false;
            // Wait a bit to make sure watcher is initialized
            setTimeout(() => {
                fs_1.writeFileSync(touchFile, `${process.hrtime.bigint()}`, { encoding: 'utf8' });
            }, 100);
        }
        else {
            resolve();
        }
    });
}));
afterAll(() => {
    // Make sure the process is killed
    eventBus.emit(EventBus_1.ChildEvents.Stop);
});
