"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_1 = require("fs");
const semver_1 = require("semver");
const child_1 = require("../child");
const dependencyDiff_1 = __importDefault(require("./dependencyDiff"));
const loadPackageJSON_1 = __importDefault(require("./loadPackageJSON"));
const store_1 = require("./store");
const EventBus_1 = require("../EventBus");
const logger_1 = __importDefault(require("../logger/logger"));
const cwd = '.';
const packageJSONPath = path_1.join(cwd, 'package.json');
const nodeModulesPath = path_1.join(cwd, 'node_modules');
const modules = ({ eventBus, pmExec = 'npm', firstRunSync = true, }) => {
    eventBus.on(EventBus_1.ModulesEvents.Install, () => {
        // Load main package.json
        const packageJSON = loadPackageJSON_1.default(packageJSONPath);
        if (!packageJSON) {
            throw new Error('Failed to load package.json');
        }
        // Load stored package.json
        const storedPackageJSON = store_1.get(packageJSON.name);
        // Setup dependency diff maps
        let missingDependencies = [];
        let extraDependencies = [];
        new Promise((resolve) => resolve())
            // Do diff between stored and current package.json
            .then(() => {
            if (storedPackageJSON) {
                const diffDependencies = dependencyDiff_1.default(storedPackageJSON.dependencies || {}, packageJSON.dependencies || {});
                const diffDevDependencies = dependencyDiff_1.default(storedPackageJSON.devDependencies || {}, packageJSON.devDependencies || {});
                // Combine dependency diffs
                missingDependencies = missingDependencies.concat(diffDependencies.added, diffDependencies.changed, diffDevDependencies.added, diffDevDependencies.changed);
                extraDependencies = extraDependencies.concat(diffDependencies.removed, diffDevDependencies.removed);
            }
        })
            // Filter out already handled modules
            .then(() => {
            missingDependencies = missingDependencies.filter((dependency) => {
                if (fs_1.existsSync(path_1.join(nodeModulesPath, dependency.name))) {
                    // Try to load the package.json for the module
                    const modulePackageJson = loadPackageJSON_1.default(path_1.join(nodeModulesPath, dependency.name, 'package.json'));
                    // If the installed module package.json version satisfies the requested, skip it
                    if (modulePackageJson && semver_1.satisfies(modulePackageJson.version, dependency.version)) {
                        return false;
                    }
                }
                return true;
            });
            extraDependencies = extraDependencies.filter((dependency) => {
                // Skip any modules that are already uninstalled
                if (!fs_1.existsSync(path_1.join(nodeModulesPath, dependency.name))) {
                    return false;
                }
                return true;
            });
        })
            // Sync dependencies
            .then(async () => {
            if (!storedPackageJSON) {
                // No previously stored dependencies
                if (firstRunSync) {
                    // eslint-disable-next-line max-len
                    logger_1.default.prefix('First execution. Running full sync (install & prune)...');
                    await child_1.childTask(`${pmExec} install --no-audit`);
                    await child_1.childTask(`${pmExec} prune`);
                }
            }
            else if (storedPackageJSON && (missingDependencies.length || extraDependencies.length)) {
                logger_1.default.prefix('Syncing dependencies...');
                // Previously stored dependencies with changes
                if (missingDependencies.length) {
                    await child_1.childTask(`${pmExec} install ${missingDependencies.map((module) => `${module.name}@${module.version}`).join(' ')} --no-audit`);
                }
                if (extraDependencies.length) {
                    await child_1.childTask(`${pmExec} uninstall ${extraDependencies.map((module) => `${module.name}@${module.version}`).join(' ')}`);
                }
            }
            // Previously stored dependencies but no changes, just continue silently
        })
            // Store the current packageJson
            .then(() => {
            store_1.set(packageJSON.name, packageJSON);
        })
            // Send installed event
            .then(() => {
            // Push installed event to message queue (make sure all message handlers are registered)
            setTimeout(() => {
                eventBus.emit(EventBus_1.ModulesEvents.Installed);
            }, 0);
        })
            .catch(() => {
            logger_1.default.prefix('Failed dependency sync.');
        });
    });
};
exports.default = modules;
